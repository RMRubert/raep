%%HP: T(0)A(D)F(.);
@ Argumentos:
@ Author: Ricardo M. Rubert
@ E-mail: RMRubert -at- gmail.com
@ Version: 2.10 Beta
@ Created using HPUserEdit 5 [www.unparche.com]
@
@ CHANGELOG:
@ **(Bug reparado)
@ ++(caracteristica añadida)
@ --(limitación solucionada)
@ //(mejora de una caracterísitca)
@
@ V2.0b:
@ // la integración en un único programa
@ -- en los limites de nudos o barras
@ ** en los apoyos NConc. El bucle solo llegaba hasta el apoyo
@
@ V2.1b:
@ ** el problema de las modificaciones CASE (solo ejecutaba el primero que se seleccionaba)
@
@ V2.2b:
@ ++ correo para consulta del personal
@ ** problema con los apoyos no concordantes, fallaba un DUP
@
@ V2.3b:
@ ** problema al añadir tirante que no lo montaba.
@
@ V2.4b:
@ ++ la opción de modificar una matriz ingresandola por variable o con MTRW
@
@ V2.5R:
@ ++ cuadros de información de que hace cada cosa en cada momento
@
@ V3.0A
@ ++ articuladas en 2D
@ // de cuadro de inicio
@
@ V3.1A
@ ** numero aleatorio que salía al principio

«
 0 1 6 0 1 2 1 1 {} {} {} 1 2 3 4 5 6 1 1 {} {}  x1 x2 St nq bq pq iq j Plista Blista Bmatrix Aq Eq Iq Lq c s SELECT SEL2 Aflex Anoc 
  «

"+--------------------+" 1 DISP 
"|    RAEP  V:3.0A    |" 2 DISP 
"| versión de prueba  |" 3 DISP 
"|                    |" 4 DISP 
"| Ricardo M. Rubert  |" 5 DISP 
"|                    |" 6 DISP 
"|  RMRubert@live.com |" 7 DISP 
"|                    |" 8 DISP 
"+--------------------+" 9 DISP 0 WAIT DROP


@PRoceso de selección@
"¿LA ESTRUCTURA ES..."
{
{ "Pórtico 2D" «1» }
{ "Artículada 2D" «2» }
{ "Pandeo P2D" «3» }
}
1
CHOOSE DROP EVAL 'SEL2' STO

CASE
    SEL2 1 ==
THEN
@@@ Portico 2D @@@
@@@ Portico 2D @@@
@@@ Portico 2D @@@
"INSERTE NÚMERO DE:"
{
{ "N" "Nudos" 0 }
{ "B" "Barras" 0 }
{ "P" "Propiedades, (Diferentes AEI)" 0 }
}
{ 3 0 }
{ }
{ }
INFORM DROP EVAL
'pq' STO 'bq' STO 'nq' STO


1 pq FOR iq
  @"{A E I} Prop:" iq +
  @{ "{}" { 0 2 } }
  @INPUT OBJ
   
   "INSERTE PROPIEDAD: " iq +
   {
   { "A" "Area de la sección" 0 }
   { "E" "Módulo de elasticidad" 0 }
   { "I" "Momento de Inercia" 0 }
   }
   { 1 0 }
   { }
   { }
   INFORM DROP
  Plista 0 + 'Plista' STO
  'Plista(iq)' STO
  
NEXT
@Plista

1 bq FOR iq
  @"{Ni Nf L a Prop}
  @Barra " iq +
  @{ "{}" { 0 2 } }
  @INPUT OBJ 
  
  "BARRA: " iq +
        {
        { "Ni" "Nudo inicial" 0 }
        { "Nf" "Nudo final" 0 }
        { "L" "Longitud de la barra" 0 }
        { "Œ" "Ángulo según criterio" 0 }
        { "Prop" "Nº de Propiedad" 0 }
        }
        { 2 0 }
        { }
        { }
        INFORM DROP
        Blista 0 + 'Blista' STO
        'Blista(iq)' STO
NEXT
@Blista 
@Sacamos la submatriz de cada barra A E I L Œ

1 bq FOR iq
  @ $$$$$$$$$$$$$$$$$$$$$$$$ @
  "Generando la matriz" 1 DISP -1 FREEZE
  "de la barra " iq + 2 DISP -1 FREEZE
  @ $$$$$$$$$$$$$$$$$$$$$$$$ @
  'Blista(iq)' EVAL 5 GET 'x1' STO @Sacamos la propiedad de la barra iq
  'Plista(x1)' EVAL EVAL @Sacamos las propiedades en orden inverso I E A
  'Iq' STO
  'Eq' STO
  'Aq' STO
  'Blista(iq)' EVAL 3 GET 'Lq' STO @Sacamos la longitud
  'Blista(iq)' EVAL 4 GET 'x1' STO @Sacamos el angulo de la barra y calculamos cos y sin
  x1 COS 'c' STO
  x1 SIN 's' STO
  @Generamos la matriz (Copy/paste de P2D v1.03)
     Eq Aq * Lq / 0 0  Eq Aq * Lq / NEG  0 0
     
     0 @@ 12 Eq * Iq * Lq 3 ^ / @@ 6 Eq * Iq * Lq 2 ^ / @@ 0 @@ 12 Eq * Iq * Lq 3 ^ / NEG @@ 6 Eq * Iq * Lq 2 ^ /
     
     0 6 Eq * Iq * Lq 2 ^ / 4 Eq * Iq * Lq /  0 6 Eq * Iq * Lq 2 ^ / NEG 2 Eq * Iq * Lq /
     
     Eq Aq * Lq / NEG 0 0  Eq Aq * Lq /  0 0
     
     0 @@ 12 Eq * Iq * Lq 3 ^ / NEG @@ 6 Eq * Iq * Lq 2 ^ / NEG @@ 0 @@ 12 Eq * Iq * Lq 3 ^ / @@ 6 Eq * Iq * Lq 2 ^ / NEG
     
     0 6 Eq * Iq * Lq 2 ^ / 2 Eq * Iq * Lq /  0 6 Eq * Iq * Lq 2 ^ / NEG 4 Eq * Iq * Lq /
     {6 6} ARRY
  @Fin de generar la Matriz
  
  @Generamos la matriz de giro (Copy/paste de G2D v1.03): Matriz G: M=G*Mo*G'
   c s NEG 0 0 0 0  
   s c 0 0 0 0  
   0 0 1 0 0 0 
   0 0 0 c s NEG 0  
   0 0 0 s c 0  
   0 0 0 0 0 1 
   {6 6} ARRY
  @Fin de generar la Matriz de giro: Matriz G: M=G*Mo*G'
  SWAP OVER TRAN * * @Hacemos M,G -> G,M -> G,M,G -> G,M,G' y multiplicamos
  Bmatrix 0 + 'Bmatrix' STO
  'Bmatrix(iq)' STO
  
NEXT

@ Modificaciones
@ ##############

-90 SF 
"MODIFICACIONES:"
{
{ "Contruir YA!" «0» }
{ "Condensar una barra" «1» }
{ "Añadir tirante" «2» }
{ "Añadir apoyo flexible" «3» }
{ "Apoyo no concordante" «4» }
{ "Mod. matriz de barra" «5» }
}
1
CHOOSE DROP EVAL 'SELECT' STO

SELECT

WHILE 
REPEAT

CASE
  SELECT 1 ==
THEN @Código de condensar una barra
"CONDENSAR BARRA:"
{
{ "B" "Nº de barra" 0 }
{ "G" "Grado a condensar" 0 }
}
{ 1 0 }
{ }
{ }
INFORM DROP
EVAL
@###x2=grado
'x2' STO 
@###x1=barra
'x1' STO 
'Bmatrix(x1)' EVAL SIZE EVAL DROP 'St' STO 
@MM
'Bmatrix(x1)' EVAL
1 St FOR iq 0 NEXT {1 St} ARRY
{x2 1} SWAP REPL
1 St FOR iq 0 NEXT  {St 1} ARRY 
{1 x2} SWAP REPL
@/MM

@MN
'Bmatrix(x1)' EVAL 
{1 x2} {St x2} SUB
0 {1 1} ARRY 
{x2 1} SWAP REPL
@/MN

@NN^-1  OJO QUE YA VA INVERTIDO!!
'Bmatrix(x1)' EVAL
{x2 x2} {x2 x2} SUB INV
@/NN^-1

@NM
'Bmatrix(x1)' EVAL 
{x2 1} {x2 St} SUB
0 {1 1} ARRY 
{1 x2} SWAP REPL
@/NM

* * -
'Bmatrix(x1)' STO
END
   SELECT 2 ==
THEN @Código del tirante
"AÑADIR TIRANTE"
{
{ "Ni" "Nudo inicial" 0 }
{ "Nf" "Nudo final" 0 }
{ "A" "Área" 0 }
{ "E" "Modulo de Elasticidad" 0 }
{ "L" "Longitud de la barra" 0 }
{ "Œ" "Ángulo" 0 }
}
{ 2 0 }
{ }
{ }
INFORM DROP
@Pedimos los datos y los añadimos en Blista.
Blista 0 + 'Blista' STO 
Blista SIZE 'iq' STO
'Blista(iq)' STO
@Sacamos el angulo
'Blista(iq)' EVAL 6 GET 'x1' STO
x1 DUP COS EVAL DUP DUP * 'c' STO SWAP SIN EVAL DUP DUP * 's' STO * 'x2' STO
  
@Construir la matriz para añadirla, c=cos², s=sin², x2= cos*sin  
  c x2 0 c NEG x2 NEG 0
  x2 s 0 x2 NEG s NEG 0
  0 0 0 0     0     0
  c NEG x2 NEG 0 c x2 0
  x2 NEG s NEG 0 x2 s 0
  0     0     0 0 0 0
  {6 6} ARRY
'Blista(iq)' EVAL 3 GET *
'Blista(iq)' EVAL 4 GET *
'Blista(iq)' EVAL 5 GET /
@Procedemos a guardar la matriz.
Bmatrix 0 + 'Bmatrix' STO
@Hemos añadido ya un 0, por ello SIZE da el resultado correcto@
Bmatrix SIZE 'iq' STO 
'Bmatrix(iq)' STO
@Añadimos una barra más al contandor@
bq 1 + 'bq' STO
END
   SELECT 3 ==
THEN @Apoyo flexible
"NUDO ELÁSTICO"
{
{ "N" "Nudo elástico" 0 }
{ "Kx" "Elásticidad en x" 0 }
{ "Ky" "Elásticidad en y" 0 }
{ "Ko" "Elásticidad al giro" 0 }
}
{ 2 0 }
{ }
{ }
INFORM DROP
        Aflex 0 + 'Aflex' STO
        Aflex SIZE 'iq' STO
        'Aflex(iq)' STO
END
   SELECT 4 ==
THEN @Apoyo no concordante.
  
"APOYO NO CONCORDANTE"
{
{ "N" "Nudo no concordante" 0 }
{ "a" "Ángulo. Cuidado con las unidades y el SR" 0 }
}
{ 1 0 }
{ }
{ }
INFORM DROP
        Anoc 0 + 'Anoc' STO
        Anoc SIZE 'iq' STO
        'Anoc(iq)' STO
END
   SELECT 5 ==
THEN
  
"MODIFICAR MATRIZ DE UNA BARRA"
{
{ "B" "Nº de barra a modificar" 0 }
{ "INSERTAR MATRIZ" "Insertar la matriz" 3 }
}
{ 1 0 }
{ }
{ }
INFORM DROP EVAL
SWAP 'iq' STO
'Bmatrix(iq)' STO 

END

END


@Salida del bucle
"MODIFICACIONES:"
{
{ "Contruir YA!" «0» }
{ "Condensar una barra" «1» }
{ "Añadir tirante" «2» }
{ "Añadir apoyo flexible" «3» }
{ "Apoyo no concordante" «4» }
{ "Mod. matriz de barra" «5» }
}
1
CHOOSE DROP EVAL 'SELECT' STO
SELECT
END


@Tenemos que crear ahora la Matriz general de la estructura de dimension 3nq·3nq

nq 3 * 'x1' STO @Generamos la matriz de la estructura llena de cero
x1 IDN 0 * @Su finalidad es poder hacer un + al final de cada bucle sin preocuparse por la primera
 
1 bq FOR iq  @Iniciamos el bucle
     
  @ $$$$$$$$$$$$$$$$$$$$$$$$ @
  "Anexionando la matriz " 1 DISP -1 FREEZE
  "de la barra " iq + 2 DISP -1 FREEZE
  @ $$$$$$$$$$$$$$$$$$$$$$$$ @

    @Generamos la matriz de la estructura llena de cero
    nq 3 * 'x1' STO
    x1 IDN 0 * @Matriz estructura llena de ceros terminada
    @Ahora rellenamos la matriz con las submatrices
    'Blista(iq)' EVAL 1 GET 'x1' STO @Sacamos el nudo 1
    'Blista(iq)' EVAL 2 GET 'x2' STO @Sacamos el nudo 2
    @   [1 | 2]
    @M= [-----]
    @   [3 | 4]
    'Bmatrix(iq)' EVAL {1 1} {3 3} SUB @Sacamos la submatriz 1
    {'x1*3-2' 'x1*3-2'} SWAP REPL @Incorporamos en la global
    'Bmatrix(iq)' EVAL {1 4} {3 6} SUB @Sacamos la submatriz 2
    {'x1*3-2' 'x2*3-2'} SWAP REPL
    'Bmatrix(iq)' EVAL {4 1} {6 3} SUB @Sacamos la submatriz 3
    {'x2*3-2' 'x1*3-2'} SWAP REPL
    'Bmatrix(iq)' EVAL {4 4} {6 6} SUB @Sacamos la submatriz 4
    {'x2*3-2' 'x2*3-2'} SWAP REPL
    + @Sumamos a la matriz anterior.
NEXT
 
@Añadimos los apoyos elásticos@
Aflex SIZE 
IF 
THEN
    1 Aflex SIZE 
    FOR iq
        DUP
        'Aflex(iq)' EVAL 1 GET 'x1' STO
          @ $$$$$$$$$$$$$$$$$$$$$$$$ @
          "Incluyendo elástico " 1 DISP -1 FREEZE
          "de la barra " x1 + 2 DISP -1 FREEZE
          @ $$$$$$$$$$$$$$$$$$$$$$$$ @        
        {'x1*3-2' 'x1*3-2'} {'x1*3' 'x1*3'} SUB
      
        'Aflex(iq)' EVAL 2 GET 0 0
        0 'Aflex(iq)' EVAL 3 GET 0
        0 0 'Aflex(iq)' EVAL 4 GET
        {3 3} ARRY 
    
        +
        {'x1*3-2' 'x1*3-2'} SWAP REPL
    NEXT
END
@Fin de añadir apoyos elásticos@

@Finalmente hacemos el apoyo no concordante@
Anoc SIZE
IF 
THEN
    1 Anoc SIZE
    FOR iq

        DUP
        'Anoc(iq)' EVAL EVAL
        DUP COS 'c' STO SIN 's' STO
        'x1' STO @nudo
        
          @ $$$$$$$$$$$$$$$$$$$$$$$$ @
          "Girando apoyo " 1 DISP -1 FREEZE
          "de la barra " x1 + 2 DISP -1 FREEZE
          @ $$$$$$$$$$$$$$$$$$$$$$$$ @
        
        @Generamos la matriz de giro@
        c s NEG 0
        s c 0
        0 0 1
        {3 3} ARRY
        'x2' STO @Ld@
        @Multiplicamos Ld' por la izda@
        1 nq  FOR j
         DUP
         {'3*x1-2' '3*j-2'} {'3*x1' '3*j'} SUB
         x2 TRAN SWAP *
         {'3*x1-2' '3*j-2'} SWAP REPL 
        NEXT
        @Multiplicamos Ld por la drcha@
         1 nq  FOR j
         DUP
         {'3*j-2' '3*x1-2'} {'3*j' '3*x1'} SUB
         x2 *
         {'3*j-2' '3*x1-2'} SWAP REPL 
        NEXT               
    NEXT
END


@###################################################################################@
@###################################################################################@
@###################################################################################@
@###################################################################################@
@@@ Articulada 2D @@###################################################@
@@@ Artículada 2D @@###################################################@
@@@ Articulada 2D @@###################################################@
@###################################################################################@
@###################################################################################@
@###################################################################################@
@###################################################################################@
@###################################################################################@
END
   SEL2 2 ==
THEN
"INSERTE NÚMERO DE:"
{
{ "N" "Nudos" 0 }
{ "B" "Barras" 0 }
{ "P" "Propiedades, (Diferentes AEI)" 0 }
}
{ 3 0 }
{ }
{ }
INFORM DROP EVAL
'pq' STO 'bq' STO 'nq' STO


1 pq FOR iq
  @"{A E I} Prop:" iq +
  @{ "{}" { 0 2 } }
  @INPUT OBJ
   
   "INSERTE PROPIEDAD: " iq +
   {
   { "A" "Area de la sección" 0 }
   { "E" "Módulo de elasticidad" 0 }
   }
   { 1 0 }
   { }
   { }
   INFORM DROP
  Plista 0 + 'Plista' STO
  'Plista(iq)' STO
  
NEXT
@Plista

1 bq FOR iq
  @"{Ni Nf L a Prop}
  @Barra " iq +
  @{ "{}" { 0 2 } }
  @INPUT OBJ 
  
  "BARRA: " iq +
        {
        { "Ni" "Nudo inicial" 0 }
        { "Nf" "Nudo final" 0 }
        { "L" "Longitud de la barra" 0 }
        { "Œ" "Ángulo según criterio" 0 }
        { "Prop" "Nº de Propiedad" 0 }
        }
        { 2 0 }
        { }
        { }
        INFORM DROP
        Blista 0 + 'Blista' STO
        'Blista(iq)' STO
NEXT
@Blista 
@Sacamos la submatriz de cada barra A E I L Œ

1 bq FOR iq
  @ $$$$$$$$$$$$$$$$$$$$$$$$ @
  "Generando la matriz" 1 DISP -1 FREEZE
  "de la barra " iq + 2 DISP -1 FREEZE
  @ $$$$$$$$$$$$$$$$$$$$$$$$ @
  'Blista(iq)' EVAL 5 GET 'x1' STO @Sacamos la propiedad de la barra iq
  'Plista(x1)' EVAL EVAL @Sacamos las propiedades en orden inverso E A
  'Eq' STO
  'Aq' STO
  'Blista(iq)' EVAL 3 GET 'Lq' STO @Sacamos la longitud
  'Blista(iq)' EVAL 4 GET 'x1' STO @Sacamos el angulo de la barra y calculamos cos y sin
  @C es cos2, s es sin2, x2 es SIN*COS
  x1 COS DUP 2 ^ 'c' STO
  x1 SIN DUP 2 ^ 's' STO
  * 'x2' STO
    c x2  c NEG x2 NEG 
  x2 s  x2 NEG s NEG 
  
  c NEG x2 NEG  c x2 
  x2 NEG s NEG  x2 s 
  {4 4} ARRY
  Eq * Aq * Lq /

  Bmatrix 0 + 'Bmatrix' STO
  'Bmatrix(iq)' STO
  
NEXT

@ Modificaciones
@ ##############

-90 SF 
"MODIFICACIONES:"
{
{ "Contruir YA!" «0» }
{ "Condensar una barra" «1» }
@{ "Añadir tirante" «2» }@
{ "Añadir apoyo flexible" «3» }
{ "Apoyo no concordante" «4» }
{ "Mod. matriz de barra" «5» }
}
1
CHOOSE DROP EVAL 'SELECT' STO

SELECT

WHILE 
REPEAT

CASE
  SELECT 1 ==
THEN @Código de condensar una barra
"CONDENSAR BARRA:"
{
{ "B" "Nº de barra" 0 }
{ "G" "Grado a condensar" 0 }
}
{ 1 0 }
{ }
{ }
INFORM DROP
EVAL
@###x2=grado
'x2' STO 
@###x1=barra
'x1' STO 
'Bmatrix(x1)' EVAL SIZE EVAL DROP 'St' STO 
@MM
'Bmatrix(x1)' EVAL
1 St FOR iq 0 NEXT {1 St} ARRY
{x2 1} SWAP REPL
1 St FOR iq 0 NEXT  {St 1} ARRY 
{1 x2} SWAP REPL
@/MM

@MN
'Bmatrix(x1)' EVAL 
{1 x2} {St x2} SUB
0 {1 1} ARRY 
{x2 1} SWAP REPL
@/MN

@NN^-1  OJO QUE YA VA INVERTIDO!!
'Bmatrix(x1)' EVAL
{x2 x2} {x2 x2} SUB INV
@/NN^-1

@NM
'Bmatrix(x1)' EVAL 
{x2 1} {x2 St} SUB
0 {1 1} ARRY 
{1 x2} SWAP REPL
@/NM

* * -
'Bmatrix(x1)' STO
END
   @SELECT 2 ==
@THEN 
@Código del tirante@
@"AÑADIR TIRANTE"
@{
@{ "Ni" "Nudo inicial" 0 }
@{ "Nf" "Nudo final" 0 }
@{ "A" "Área" 0 }
@{ "E" "Modulo de Elasticidad" 0 }
@{ "L" "Longitud de la barra" 0 }
@{ "Œ" "Ángulo" 0 }
@}
@{ 2 0 }
@{ }
@{ }
@INFORM DROP
@Pedimos los datos y los añadimos en Blista.
@Blista 0 + 'Blista' STO 
@Blista SIZE 'iq' STO
@'Blista(iq)' STO
@Sacamos el angulo
@'Blista(iq)' EVAL 6 GET 'x1' STO
@x1 DUP COS EVAL DUP DUP * 'c' STO SWAP SIN EVAL DUP DUP * 's' STO * 'x2' STO
  
@Construir la matriz para añadirla, c=cos², s=sin², x2= cos*sin  
  @c x2 0 c NEG x2 NEG 0
  @x2 s 0 x2 NEG s NEG 0
  @0 0 0 0     0     0
  @c NEG x2 NEG 0 c x2 0
  @x2 NEG s NEG 0 x2 s 0
  @0     0     0 0 0 0
  @{6 6} ARRY
@'Blista(iq)' EVAL 3 GET *
@'Blista(iq)' EVAL 4 GET *
@'Blista(iq)' EVAL 5 GET /
@Procedemos a guardar la matriz.
@Bmatrix 0 + 'Bmatrix' STO
@Hemos añadido ya un 0, por ello SIZE da el resultado correcto@
@Bmatrix SIZE 'iq' STO 
@'Bmatrix(iq)' STO
@Añadimos una barra más al contandor@
@bq 1 + 'bq' STO
@END
   SELECT 3 ==
THEN @Apoyo flexible
"NUDO ELÁSTICO"
{
{ "N" "Nudo elástico" 0 }
{ "Kx" "Elásticidad en x" 0 }
{ "Ky" "Elásticidad en y" 0 }
}
{ 2 0 }
{ }
{ }
INFORM DROP
        Aflex 0 + 'Aflex' STO
        Aflex SIZE 'iq' STO
        'Aflex(iq)' STO
END
   SELECT 4 ==
THEN @Apoyo no concordante.
  
"APOYO NO CONCORDANTE"
{
{ "N" "Nudo no concordante" 0 }
{ "a" "Ángulo. Cuidado con las unidades y el SR" 0 }
}
{ 1 0 }
{ }
{ }
INFORM DROP
        Anoc 0 + 'Anoc' STO
        Anoc SIZE 'iq' STO
        'Anoc(iq)' STO
END
   SELECT 5 ==
THEN
  
"MODIFICAR MATRIZ DE UNA BARRA"
{
{ "B" "Nº de barra a modificar" 0 }
{ "INSERTAR MATRIZ" "Insertar la matriz" 3 }
}
{ 1 0 }
{ }
{ }
INFORM DROP EVAL
SWAP 'iq' STO
'Bmatrix(iq)' STO 

END

END


@Salida del bucle
"MODIFICACIONES:"
{
{ "Contruir YA!" «0» }
{ "Condensar una barra" «1» }
@{ "Añadir tirante" «2» }@
{ "Añadir apoyo flexible" «3» }
{ "Apoyo no concordante" «4» }
{ "Mod. matriz de barra" «5» }
}
1
CHOOSE DROP EVAL 'SELECT' STO
SELECT
END


@Tenemos que crear ahora la Matriz general de la estructura de dimension 3nq·3nq

nq 2 * @Generamos la matriz de la estructura llena de cero
IDN 0 * @Su finalidad es poder hacer un + al final de cada bucle sin preocuparse por la primera
 
1 bq FOR iq  @Iniciamos el bucle
     
  @ $$$$$$$$$$$$$$$$$$$$$$$$ @
  "Anexionando la matriz " 1 DISP -1 FREEZE
  "de la barra " iq + 2 DISP -1 FREEZE
  @ $$$$$$$$$$$$$$$$$$$$$$$$ @

    @Generamos la matriz de la estructura llena de cero
    nq 2 * IDN 0 * @Matriz estructura llena de ceros terminada
    @Ahora rellenamos la matriz con las submatrices
    'Blista(iq)' EVAL 1 GET 'x1' STO @Sacamos el nudo 1
    'Blista(iq)' EVAL 2 GET 'x2' STO @Sacamos el nudo 2
    @   [1 | 2]
    @M= [-----]
    @   [3 | 4]
    'Bmatrix(iq)' EVAL {1 1} {2 2} SUB @Sacamos la submatriz 1
    {'x1*2-1' 'x1*2-1'} SWAP REPL @Incorporamos en la global
    'Bmatrix(iq)' EVAL {1 3} {2 4} SUB @Sacamos la submatriz 2
    {'x1*2-1' 'x2*2-1'} SWAP REPL
    'Bmatrix(iq)' EVAL {3 1} {4 2} SUB @Sacamos la submatriz 3
    {'x2*2-1' 'x1*2-1'} SWAP REPL
    'Bmatrix(iq)' EVAL {3 3} {4 4} SUB @Sacamos la submatriz 4
    {'x2*2-1' 'x2*2-1'} SWAP REPL
    + @Sumamos a la matriz anterior.
NEXT
 
@Añadimos los apoyos elásticos@
Aflex SIZE 
IF 
THEN
    1 Aflex SIZE 
    FOR iq
        DUP
        'Aflex(iq)' EVAL 1 GET 'x1' STO
          @ $$$$$$$$$$$$$$$$$$$$$$$$ @
          "Incluyendo elástico " 1 DISP -1 FREEZE
          "de la barra " x1 + 2 DISP -1 FREEZE
          @ $$$$$$$$$$$$$$$$$$$$$$$$ @        
        {'x1*2-1' 'x1*2-1'} {'x1*2' 'x1*2'} SUB
      
        'Aflex(iq)' EVAL 2 GET 0 
        0 'Aflex(iq)' EVAL 3 GET 
        {2 2} ARRY 
    
        +
        {'x1*2-1' 'x1*2-1'} SWAP REPL
    NEXT
END
@Fin de añadir apoyos elásticos@

@Finalmente hacemos el apoyo no concordante@
Anoc SIZE
IF 
THEN
    1 Anoc SIZE
    FOR iq

        DUP
        'Anoc(iq)' EVAL EVAL
        DUP COS 'c' STO SIN 's' STO
        'x1' STO @nudo
        
          @ $$$$$$$$$$$$$$$$$$$$$$$$ @
          "Girando apoyo " 1 DISP -1 FREEZE
          "de la barra " x1 + 2 DISP -1 FREEZE
          @ $$$$$$$$$$$$$$$$$$$$$$$$ @
        
        @Generamos la matriz de giro@
        c s NEG
        s c
        {2 2} ARRY
        'x2' STO @Ld@
        @Multiplicamos Ld' por la izda@
        1 nq  FOR j
         DUP
         {'2*x1-1' '2*j-1'} {'2*x1' '2*j'} SUB
         x2 TRAN SWAP *
         {'2*x1-1' '2*j-1'} SWAP REPL 
        NEXT
        @Multiplicamos Ld por la drcha@
         1 nq  FOR j
         DUP
         {'2*j-1' '2*x1-1'} {'2*j' '2*x1'} SUB
         x2 *
         {'2*j-1' '2*x1-1'} SWAP REPL 
        NEXT               
    NEXT
END

END @del then del CASE 
    SEL2 3 ==
THEN
  "No soportado" MSGBOX
END
END @del CASE


'EstM' STO
"¿DESEA MOSTRAR ..."
{
{ "Kest" « EstM » } 
{ "Kest y Kbar" « Bmatrix EstM » }
}
1
CHOOSE DROP EVAL
  »
»